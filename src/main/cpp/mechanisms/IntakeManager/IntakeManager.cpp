//====================================================================================================================================================
// Copyright 2025 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.25.00.05
// Generated on Sunday, February 16, 2025 10:12:00 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>

#include "IntakeManager.h"
#include "utils/logging/Logger.h"
#include "utils/PeriodicLooper.h"
#include "state/RobotState.h"
#include "teleopcontrol/TeleopControl.h"

#include "ctre/phoenix6/TalonFXS.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configs.hpp"
#include <frc/DigitalInput.h>
#include <frc/filter/Debouncer.h>
#include "mechanisms/IntakeManager/OffState.h"
#include "mechanisms/IntakeManager/IntakeState.h"
#include "mechanisms/IntakeManager/HoldState.h"
#include "mechanisms/IntakeManager/TransferInState.h"
#include "mechanisms/IntakeManager/TransferOutState.h"
#include "mechanisms/IntakeManager/ProcessState.h"
#include "mechanisms/IntakeManager/ExpelState.h"

using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::Slot1Configs;
using ctre::phoenix6::configs::TalonFXSConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;
using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::MotorArrangementValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;

using std::string;
using namespace IntakeManagerStates;

void IntakeManager::CreateAndRegisterStates()
{
	OffState *OffStateInst = new OffState(string("Off"), 0, this, m_activeRobotId);
	AddToStateVector(OffStateInst);

	IntakeState *IntakeStateInst = new IntakeState(string("Intake"), 1, this, m_activeRobotId);
	AddToStateVector(IntakeStateInst);

	HoldState *HoldStateInst = new HoldState(string("Hold"), 2, this, m_activeRobotId);
	AddToStateVector(HoldStateInst);

	TransferInState *TransferInStateInst = new TransferInState(string("TransferIn"), 3, this, m_activeRobotId);
	AddToStateVector(TransferInStateInst);

	TransferOutState *TransferOutStateInst = new TransferOutState(string("TransferOut"), 4, this, m_activeRobotId);
	AddToStateVector(TransferOutStateInst);

	ProcessState *ProcessStateInst = new ProcessState(string("Process"), 5, this, m_activeRobotId);
	AddToStateVector(ProcessStateInst);

	ExpelState *ExpelStateInst = new ExpelState(string("Expel"), 6, this, m_activeRobotId);
	AddToStateVector(ExpelStateInst);

	OffStateInst->RegisterTransitionState(IntakeStateInst);
	OffStateInst->RegisterTransitionState(ExpelStateInst);
	IntakeStateInst->RegisterTransitionState(OffStateInst);
	IntakeStateInst->RegisterTransitionState(HoldStateInst);
	IntakeStateInst->RegisterTransitionState(ExpelStateInst);
	HoldStateInst->RegisterTransitionState(OffStateInst);
	HoldStateInst->RegisterTransitionState(ProcessStateInst);
	HoldStateInst->RegisterTransitionState(ExpelStateInst);
	TransferInStateInst->RegisterTransitionState(HoldStateInst);
	TransferOutStateInst->RegisterTransitionState(OffStateInst);
	ProcessStateInst->RegisterTransitionState(OffStateInst);
	ExpelStateInst->RegisterTransitionState(OffStateInst);
}

IntakeManager::IntakeManager(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::INTAKE_MANAGER, std::string("IntakeManager")),
															  m_activeRobotId(activeRobotId),
															  m_stateMap()
{
	PeriodicLooper::GetInstance()->RegisterAll(this);
}

std::map<std::string, IntakeManager::STATE_NAMES> IntakeManager::stringToSTATE_NAMESEnumMap{
	{"STATE_OFF", IntakeManager::STATE_NAMES::STATE_OFF},
	{"STATE_INTAKE", IntakeManager::STATE_NAMES::STATE_INTAKE},
	{"STATE_HOLD", IntakeManager::STATE_NAMES::STATE_HOLD},
	{"STATE_TRANSFER_IN", IntakeManager::STATE_NAMES::STATE_TRANSFER_IN},
	{"STATE_TRANSFER_OUT", IntakeManager::STATE_NAMES::STATE_TRANSFER_OUT},
	{"STATE_PROCESS", IntakeManager::STATE_NAMES::STATE_PROCESS},
	{"STATE_EXPEL", IntakeManager::STATE_NAMES::STATE_EXPEL},
};

void IntakeManager::CreatePRACTICE_BOT9999()
{
	m_ntName = "IntakeManager";
	m_Intake = new ctre::phoenix6::hardware::TalonFXS(50, "rio");
	m_Extender = new ctre::phoenix6::hardware::TalonFXS(51, "rio");

	m_IntakeSensor = new frc::DigitalInput(3);

	m_PercentOutput = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOutput",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
		0,										// double integralZone
		0,										// double maxAcceleration
		0,										// double cruiseVelocity
		0,										// double peakValue
		0,										// double nominalValue
		false									// bool enableFOC
	);
	m_PositionDegree = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegree",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
		0,										// double integralZone
		0,										// double maxAcceleration
		0,										// double cruiseVelocity
		0,										// double peakValue
		0,										// double nominalValue
		true									// bool enableFOC
	);

	ReadConstants("IntakeManager.xml", 9999);

	m_table = nt::NetworkTableInstance::GetDefault().GetTable(m_ntName);
	m_tuningIsEnabledStr = "Enable Tuning for " + m_ntName; // since this string is used every loop, we do not want to create the string every time
	m_table.get()->PutBoolean(m_tuningIsEnabledStr, m_tuning);
}

void IntakeManager::CreateCOMP_BOT302()
{
	m_ntName = "IntakeManager";
	m_Intake = new ctre::phoenix6::hardware::TalonFXS(15, "rio");
	m_Extender = new ctre::phoenix6::hardware::TalonFXS(6, "rio");

	m_IntakeSensor = new frc::DigitalInput(3);

	m_PercentOutput = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOutput",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
		0,										// double integralZone
		0,										// double maxAcceleration
		0,										// double cruiseVelocity
		0,										// double peakValue
		0,										// double nominalValue
		false									// bool enableFOC
	);
	m_PositionDegree = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegree",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
		0,										// double integralZone
		0,										// double maxAcceleration
		0,										// double cruiseVelocity
		0,										// double peakValue
		0,										// double nominalValue
		true									// bool enableFOC
	);

	ReadConstants("IntakeManager.xml", 302);

	m_table = nt::NetworkTableInstance::GetDefault().GetTable(m_ntName);
	m_tuningIsEnabledStr = "Enable Tuning for " + m_ntName; // since this string is used every loop, we do not want to create the string every time
	m_table.get()->PutBoolean(m_tuningIsEnabledStr, m_tuning);
}

void IntakeManager::InitializePRACTICE_BOT9999()
{
	InitializeTalonFXSIntakePRACTICE_BOT9999();
	InitializeTalonFXSExtenderPRACTICE_BOT9999();
}

void IntakeManager::InitializeCOMP_BOT302()
{
	InitializeTalonFXSIntakeCOMP_BOT302();
	InitializeTalonFXSExtenderCOMP_BOT302();
}
void IntakeManager::InitializeTalonFXSIntakePRACTICE_BOT9999()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.2);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.OpenLoopRamps.VoltageOpenLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	configs.ExternalFeedback.ExternalFeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.ExternalFeedback.SensorToMechanismRatio = 4;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Intake->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Intake", "m_Intake Status", status.GetName());
}

void IntakeManager::InitializeTalonFXSExtenderPRACTICE_BOT9999()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.2);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	configs.ExternalFeedback.ExternalFeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.ExternalFeedback.SensorToMechanismRatio = 405;
	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Extender->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Extender", "m_Extender Status", status.GetName());
}

// IntakeSensor : Digital inputs do not have initialization needs
void IntakeManager::InitializeTalonFXSIntakeCOMP_BOT302()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.2);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.OpenLoopRamps.VoltageOpenLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.ExternalFeedback.ExternalFeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.ExternalFeedback.SensorToMechanismRatio = 4;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Intake->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Intake", "m_Intake Status", status.GetName());
}

void IntakeManager::InitializeTalonFXSExtenderCOMP_BOT302()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.2);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(95);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	configs.ExternalFeedback.ExternalFeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.ExternalFeedback.SensorToMechanismRatio = 405;

	m_ExtenderPositionDegree.EnableFOC = true;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Extender->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Extender", "m_Extender Status", status.GetName());
}

// IntakeSensor : Digital inputs do not have initialization needs

void IntakeManager::SetPIDExtenderPositionDegree()
{
	Slot0Configs slot0Configs{};
	slot0Configs.kP = m_PositionDegree->GetP();
	slot0Configs.kI = m_PositionDegree->GetI();
	slot0Configs.kD = m_PositionDegree->GetD();
	slot0Configs.kG = m_PositionDegree->GetF();
	slot0Configs.kS = m_PositionDegree->GetS();
	slot0Configs.kV = m_PositionDegree->GetV();
	slot0Configs.kA = m_PositionDegree->GetA();
	m_Extender->GetConfigurator().Apply(slot0Configs);
}

void IntakeManager::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
	PeriodicLooper::GetInstance()->RegisterAll(this);
}

void IntakeManager::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();

	auto controller = TeleopControl::GetInstance();
	if (controller->IsButtonPressed(TeleopControlFunctions::FAILED_INTAKE_SENSOR))
	{
		if (m_manualModeButtonReleased)
			m_failedSensorLatch = !m_failedSensorLatch;
	}
	m_manualModeButtonReleased = !controller->IsButtonPressed(TeleopControlFunctions::FAILED_INTAKE_SENSOR);
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void IntakeManager::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void IntakeManager::Update()
{
	m_Intake->SetControl(*m_IntakeActiveTarget);
	m_Extender->SetControl(*m_ExtenderActiveTarget);
}

bool IntakeManager::IsAtMinPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMinTravel();
	// }
	return false;
}

bool IntakeManager::IsAtMaxPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMaxTravel();
	// }
	return false;
}

void IntakeManager::Cyclic()
{
	Update();

	CheckForTuningEnabled();
	if (m_tuning)
	{
		ReadTuningParamsFromNT();
	}
}

void IntakeManager::CheckForTuningEnabled()
{
	bool pastTuning = m_tuning;
	m_tuning = m_table.get()->GetBoolean(m_tuningIsEnabledStr, false);
	if (pastTuning != m_tuning && m_tuning == true)
	{
		PushTuningParamsToNT();
	}
}

void IntakeManager::ReadTuningParamsFromNT()
{
	m_PositionDegree->SetIZone(m_table.get()->GetNumber("PositionDegree_iZone", 0));
	m_PositionDegree->SetS(m_table.get()->GetNumber("PositionDegree_sGain", 0));
	m_PositionDegree->SetV(m_table.get()->GetNumber("PositionDegree_vGain", 0));
	m_PositionDegree->SetA(m_table.get()->GetNumber("PositionDegree_aGain", 0));
	m_PositionDegree->SetF(m_table.get()->GetNumber("PositionDegree_fGain", 0));
	m_PositionDegree->SetP(m_table.get()->GetNumber("PositionDegree_pGain", 0));
	m_PositionDegree->SetI(m_table.get()->GetNumber("PositionDegree_iGain", 0));
	m_PositionDegree->SetD(m_table.get()->GetNumber("PositionDegree_dGain", 0));
}

void IntakeManager::PushTuningParamsToNT()
{
	m_table.get()->PutNumber("PositionDegree_iZone", m_PositionDegree->GetIZone());
	m_table.get()->PutNumber("PositionDegree_sGain", m_PositionDegree->GetS());
	m_table.get()->PutNumber("PositionDegree_vGain", m_PositionDegree->GetV());
	m_table.get()->PutNumber("PositionDegree_aGain", m_PositionDegree->GetA());
	m_table.get()->PutNumber("PositionDegree_fGain", m_PositionDegree->GetF());
	m_table.get()->PutNumber("PositionDegree_pGain", m_PositionDegree->GetP());
	m_table.get()->PutNumber("PositionDegree_iGain", m_PositionDegree->GetI());
	m_table.get()->PutNumber("PositionDegree_dGain", m_PositionDegree->GetD());
}

ControlData *IntakeManager::GetControlData(string name)
{
	if (name.compare("PercentOutput") == 0)
		return m_PercentOutput;
	if (name.compare("PositionDegree") == 0)
		return m_PositionDegree;

	return nullptr;
}