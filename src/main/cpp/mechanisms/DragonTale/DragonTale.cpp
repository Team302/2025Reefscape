//====================================================================================================================================================
// Copyright 2025 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.25.00.02
// Generated on Friday, January 24, 2025 8:21:52 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>

#include "DragonTale.h"
#include "utils/logging/Logger.h"
#include "utils/PeriodicLooper.h"

#include "ctre/phoenix6/TalonFX.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configs.hpp"
#include <ctre/phoenix/motorcontrol/can/TalonSRX.h>
#include <ctre/phoenix/motorcontrol/SupplyCurrentLimitConfiguration.h>
#include <frc/DigitalInput.h>
#include <frc/filter/Debouncer.h>
#include <ctre/phoenix6/CANcoder.hpp>
#include <ctre/phoenix6/configs/Configurator.hpp>
#include <ctre/phoenix6/signals/SpnEnums.hpp>
#include "mechanisms/DragonTale/InitializeState.h"
#include "mechanisms/DragonTale/ReadyState.h"
#include "mechanisms/DragonTale/HumanPlayerLoadState.h"
#include "mechanisms/DragonTale/GrabAlgaeReefState.h"
#include "mechanisms/DragonTale/HoldState.h"
#include "mechanisms/DragonTale/GrabAlgaeFloorState.h"
#include "mechanisms/DragonTale/ProcessState.h"
#include "mechanisms/DragonTale/NetState.h"
#include "mechanisms/DragonTale/ScoreAlgaeState.h"
#include "mechanisms/DragonTale/L1ScoringPositionState.h"
#include "mechanisms/DragonTale/L2ScoringPositionState.h"
#include "mechanisms/DragonTale/L3ScoringPositionState.h"
#include "mechanisms/DragonTale/L4ScoringPositionState.h"
#include "mechanisms/DragonTale/ScoreCoralState.h"
#include "mechanisms/DragonTale/ManualCoralLoadState.h"
#include "mechanisms/DragonTale/ManualGrabAlgaeReefState.h"
#include "mechanisms/DragonTale/ManualGrabAlgaeFloorState.h"

#include "teleopcontrol/TeleopControl.h"
#include "teleopcontrol/TeleopControlFunctions.h"

#include "state/RobotState.h"
#include "utils/AngleUtils.h"
#include "utils/FMSData.h"

using ctre::phoenix6::configs::ClosedLoopRampsConfigs;
using ctre::phoenix6::configs::CurrentLimitsConfigs;
using ctre::phoenix6::configs::HardwareLimitSwitchConfigs;
using ctre::phoenix6::configs::MotorOutputConfigs;
using ctre::phoenix6::configs::OpenLoopRampsConfigs;
using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::TalonFXConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;
using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;

using std::string;
using namespace DragonTaleStates;

void DragonTale::CreateAndRegisterStates()
{
	InitializeState *InitializeStateInst = new InitializeState(string("Initialize"), 0, this, m_activeRobotId);
	AddToStateVector(InitializeStateInst);

	ReadyState *ReadyStateInst = new ReadyState(string("Ready"), 1, this, m_activeRobotId);
	AddToStateVector(ReadyStateInst);

	HumanPlayerLoadState *HumanPlayerLoadStateInst = new HumanPlayerLoadState(string("HumanPlayerLoad"), 2, this, m_activeRobotId);
	AddToStateVector(HumanPlayerLoadStateInst);

	GrabAlgaeReefState *GrabAlgaeReefStateInst = new GrabAlgaeReefState(string("GrabAlgaeReef"), 3, this, m_activeRobotId);
	AddToStateVector(GrabAlgaeReefStateInst);

	HoldState *HoldStateInst = new HoldState(string("Hold"), 4, this, m_activeRobotId);
	AddToStateVector(HoldStateInst);

	GrabAlgaeFloorState *GrabAlgaeFloorStateInst = new GrabAlgaeFloorState(string("GrabAlgaeFloor"), 5, this, m_activeRobotId);
	AddToStateVector(GrabAlgaeFloorStateInst);

	ProcessState *ProcessStateInst = new ProcessState(string("Process"), 6, this, m_activeRobotId);
	AddToStateVector(ProcessStateInst);

	NetState *NetStateInst = new NetState(string("Net"), 7, this, m_activeRobotId);
	AddToStateVector(NetStateInst);

	ScoreAlgaeState *ScoreAlgaeStateInst = new ScoreAlgaeState(string("ScoreAlgae"), 8, this, m_activeRobotId);
	AddToStateVector(ScoreAlgaeStateInst);

	L1ScoringPositionState *L1ScoringPositionStateInst = new L1ScoringPositionState(string("L1ScoringPosition"), 9, this, m_activeRobotId);
	AddToStateVector(L1ScoringPositionStateInst);

	L2ScoringPositionState *L2ScoringPositionStateInst = new L2ScoringPositionState(string("L2ScoringPosition"), 10, this, m_activeRobotId);
	AddToStateVector(L2ScoringPositionStateInst);

	L3ScoringPositionState *L3ScoringPositionStateInst = new L3ScoringPositionState(string("L3ScoringPosition"), 11, this, m_activeRobotId);
	AddToStateVector(L3ScoringPositionStateInst);

	L4ScoringPositionState *L4ScoringPositionStateInst = new L4ScoringPositionState(string("L4ScoringPosition"), 12, this, m_activeRobotId);
	AddToStateVector(L4ScoringPositionStateInst);

	ScoreCoralState *ScoreCoralStateInst = new ScoreCoralState(string("ScoreCoral"), 13, this, m_activeRobotId);
	AddToStateVector(ScoreCoralStateInst);

	ManualCoralLoadState *ManualCoralLoadStateInst = new ManualCoralLoadState(string("ManualCoralLoad"), 14, this, m_activeRobotId);
	AddToStateVector(ManualCoralLoadStateInst);

	ManualGrabAlgaeReefState *ManualGrabAlgaeReefStateInst = new ManualGrabAlgaeReefState(string("ManualGrabAlgaeReef"), 15, this, m_activeRobotId);
	AddToStateVector(ManualGrabAlgaeReefStateInst);

	ManualGrabAlgaeFloorState *ManualGrabAlgaeFloorStateInst = new ManualGrabAlgaeFloorState(string("ManualGrabAlgaeFloor"), 16, this, m_activeRobotId);
	AddToStateVector(ManualGrabAlgaeFloorStateInst);

	InitializeStateInst->RegisterTransitionState(ReadyStateInst);
	ReadyStateInst->RegisterTransitionState(HumanPlayerLoadStateInst);
	ReadyStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	ReadyStateInst->RegisterTransitionState(GrabAlgaeFloorStateInst);
	HumanPlayerLoadStateInst->RegisterTransitionState(ReadyStateInst);
	HumanPlayerLoadStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	HumanPlayerLoadStateInst->RegisterTransitionState(HoldStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(ReadyStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(HumanPlayerLoadStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(HoldStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(GrabAlgaeFloorStateInst);
	HoldStateInst->RegisterTransitionState(ReadyStateInst);
	HoldStateInst->RegisterTransitionState(HumanPlayerLoadStateInst);
	HoldStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	HoldStateInst->RegisterTransitionState(GrabAlgaeFloorStateInst);
	HoldStateInst->RegisterTransitionState(ProcessStateInst);
	HoldStateInst->RegisterTransitionState(NetStateInst);
	HoldStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	HoldStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	HoldStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	HoldStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	GrabAlgaeFloorStateInst->RegisterTransitionState(ReadyStateInst);
	GrabAlgaeFloorStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	GrabAlgaeFloorStateInst->RegisterTransitionState(HoldStateInst);
	ProcessStateInst->RegisterTransitionState(ReadyStateInst);
	ProcessStateInst->RegisterTransitionState(HoldStateInst);
	ProcessStateInst->RegisterTransitionState(NetStateInst);
	ProcessStateInst->RegisterTransitionState(ScoreAlgaeStateInst);
	NetStateInst->RegisterTransitionState(ReadyStateInst);
	NetStateInst->RegisterTransitionState(HoldStateInst);
	NetStateInst->RegisterTransitionState(ProcessStateInst);
	NetStateInst->RegisterTransitionState(ScoreAlgaeStateInst);
	ScoreAlgaeStateInst->RegisterTransitionState(ReadyStateInst);
	ScoreAlgaeStateInst->RegisterTransitionState(HoldStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	ScoreCoralStateInst->RegisterTransitionState(ReadyStateInst);
	ScoreCoralStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	ScoreCoralStateInst->RegisterTransitionState(HoldStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(ManualGrabAlgaeReefStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ProcessStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(NetStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ManualCoralLoadStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ManualGrabAlgaeFloorStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ProcessStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(NetStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ManualCoralLoadStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ManualGrabAlgaeReefStateInst);
}

DragonTale::DragonTale(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::DRAGON_TALE, std::string("DragonTale")),
														m_activeRobotId(activeRobotId),
														m_stateMap()

{
	m_scoringMode = RobotStateChanges::ScoringMode::Coral;
	RobotState *m_robotState = RobotState::GetInstance();

	m_robotState->RegisterForStateChanges(this, RobotStateChanges::StateChange::DesiredScoringMode_Int);
	PeriodicLooper::GetInstance()->RegisterAll(this);
}

std::map<std::string, DragonTale::STATE_NAMES> DragonTale::stringToSTATE_NAMESEnumMap{
	{"STATE_INITIALIZE", DragonTale::STATE_NAMES::STATE_INITIALIZE},
	{"STATE_READY", DragonTale::STATE_NAMES::STATE_READY},
	{"STATE_HUMAN_PLAYER_LOAD", DragonTale::STATE_NAMES::STATE_HUMAN_PLAYER_LOAD},
	{"STATE_GRAB_ALGAE_REEF", DragonTale::STATE_NAMES::STATE_GRAB_ALGAE_REEF},
	{"STATE_HOLD", DragonTale::STATE_NAMES::STATE_HOLD},
	{"STATE_GRAB_ALGAE_FLOOR", DragonTale::STATE_NAMES::STATE_GRAB_ALGAE_FLOOR},
	{"STATE_PROCESS", DragonTale::STATE_NAMES::STATE_PROCESS},
	{"STATE_NET", DragonTale::STATE_NAMES::STATE_NET},
	{"STATE_SCORE_ALGAE", DragonTale::STATE_NAMES::STATE_SCORE_ALGAE},
	{"STATE_L1SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L1SCORING_POSITION},
	{"STATE_L2SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L2SCORING_POSITION},
	{"STATE_L3SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L3SCORING_POSITION},
	{"STATE_L4SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L4SCORING_POSITION},
	{"STATE_SCORE_CORAL", DragonTale::STATE_NAMES::STATE_SCORE_CORAL},
	{"STATE_MANUAL_CORAL_LOAD", DragonTale::STATE_NAMES::STATE_MANUAL_CORAL_LOAD},
	{"STATE_MANUAL_GRAB_ALGAE_REEF", DragonTale::STATE_NAMES::STATE_MANUAL_GRAB_ALGAE_REEF},
	{"STATE_MANUAL_GRAB_ALGAE_FLOOR", DragonTale::STATE_NAMES::STATE_MANUAL_GRAB_ALGAE_FLOOR},
};

void DragonTale::CreatePRACTICE_BOT9999()
{
	m_ntName = "DragonTale";
	m_Arm = new ctre::phoenix6::hardware::TalonFX(0, "rio");
	m_ElevatorLeader = new ctre::phoenix6::hardware::TalonFX(8, "rio");
	m_Coral = new ctre::phoenix::motorcontrol::can::TalonSRX(0);
	m_Algae = new ctre::phoenix::motorcontrol::can::TalonSRX(0);
	m_ElevatorFollower = new ctre::phoenix6::hardware::TalonFX(13, "rio");

	m_CoralInSensor = new frc::DigitalInput(0);
	m_CoralOutSensor = new frc::DigitalInput(0);
	m_AlgaeSensor = new frc::DigitalInput(0);

	ctre::phoenix6::configs::CANcoderConfiguration ArmAngleSensorConfigs{};
	ArmAngleSensorConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(0);
	ArmAngleSensorConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_ArmAngleSensor = new ctre::phoenix6::hardware::CANcoder(0, "rio");
	m_ArmAngleSensor->GetConfigurator().Apply(ArmAngleSensorConfigs);
	ctre::phoenix6::configs::CANcoderConfiguration ElevatorHeightSensorConfigs{};
	ElevatorHeightSensorConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(0);
	ElevatorHeightSensorConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_ElevatorHeightSensor = new ctre::phoenix6::hardware::CANcoder(0, "rio");
	m_ElevatorHeightSensor->GetConfigurator().Apply(ElevatorHeightSensorConfigs);

	m_PositionInch = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_INCH,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionInch",								  // std::string indentifier
		0.2,											  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		ControlData::FEEDFORWARD_TYPE::VOLTAGE,			  // FEEDFORWARD_TYPE feedforwadType
		0,												  // double integralZone
		0,												  // double maxAcceleration
		0,												  // double cruiseVelocity
		0,												  // double peakValue
		0,												  // double nominalValue
		true											  // bool enableFOC
	);
	m_PositionDegree = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegree",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		ControlData::FEEDFORWARD_TYPE::VOLTAGE,			  // FEEDFORWARD_TYPE feedforwadType
		0,												  // double integralZone
		0,												  // double maxAcceleration
		0,												  // double cruiseVelocity
		0,												  // double peakValue
		0,												  // double nominalValue
		true											  // bool enableFOC
	);
	m_PercentOutput = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOutput",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		ControlData::FEEDFORWARD_TYPE::VOLTAGE,			  // FEEDFORWARD_TYPE feedforwadType
		0,												  // double integralZone
		0,												  // double maxAcceleration
		0,												  // double cruiseVelocity
		0,												  // double peakValue
		0,												  // double nominalValue
		false											  // bool enableFOC
	);

	ReadConstants("DragonTale.xml", 9999);

	m_table = nt::NetworkTableInstance::GetDefault().GetTable(m_ntName);
	m_tuningIsEnabledStr = "Enable Tuning for " + m_ntName; // since this string is used every loop, we do not want to create the string every time
	m_table.get()->PutBoolean(m_tuningIsEnabledStr, m_tuning);
}

void DragonTale::InitializePRACTICE_BOT9999()
{
	InitializeTalonFXArmPRACTICE_BOT9999();
	InitializeTalonFXElevatorLeaderPRACTICE_BOT9999();
	InitializeTalonSRXCoralPRACTICE_BOT9999();
	InitializeTalonSRXAlgaePRACTICE_BOT9999();
	InitializeTalonFXElevatorFollowerPRACTICE_BOT9999();
}
void DragonTale::InitializeTalonFXArmPRACTICE_BOT9999()
{
	CurrentLimitsConfigs currconfigs{};
	currconfigs.StatorCurrentLimit = units::current::ampere_t(0);
	currconfigs.StatorCurrentLimitEnable = false;
	currconfigs.SupplyCurrentLimit = units::current::ampere_t(70);
	currconfigs.SupplyCurrentLimitEnable = true;
	currconfigs.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	currconfigs.SupplyCurrentLowerTime = units::time::second_t(0.25);
	m_Arm->GetConfigurator().Apply(currconfigs);

	ClosedLoopRampsConfigs rampConfigs{};
	rampConfigs.TorqueClosedLoopRampPeriod = units::time::second_t(0.5);
	m_Arm->GetConfigurator().Apply(rampConfigs);
	HardwareLimitSwitchConfigs hwswitch{};
	hwswitch.ForwardLimitEnable = true;
	hwswitch.ForwardLimitRemoteSensorID = 0;
	hwswitch.ForwardLimitAutosetPositionEnable = false;
	hwswitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	hwswitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	hwswitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	hwswitch.ReverseLimitEnable = true;
	hwswitch.ReverseLimitRemoteSensorID = 0;
	hwswitch.ReverseLimitAutosetPositionEnable = false;
	hwswitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	hwswitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	hwswitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;
	m_Arm->GetConfigurator().Apply(hwswitch);

	MotorOutputConfigs motorconfig{};
	motorconfig.Inverted = InvertedValue::CounterClockwise_Positive;
	motorconfig.NeutralMode = NeutralModeValue::Brake;
	motorconfig.PeakForwardDutyCycle = 1;
	motorconfig.PeakReverseDutyCycle = -1;
	motorconfig.DutyCycleNeutralDeadband = 0;
	m_Arm->GetConfigurator().Apply(motorconfig);
	TalonFXConfiguration fxConfig{};
	fxConfig.Feedback.FeedbackRemoteSensorID = 0;
	fxConfig.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::FusedCANcoder;
	fxConfig.Feedback.SensorToMechanismRatio = 1;
	fxConfig.Feedback.RotorToSensorRatio = 240;
	m_Arm->GetConfigurator().Apply(fxConfig);
}

void DragonTale::InitializeTalonFXElevatorLeaderPRACTICE_BOT9999()
{
	CurrentLimitsConfigs currconfigs{};
	currconfigs.StatorCurrentLimit = units::current::ampere_t(0);
	currconfigs.StatorCurrentLimitEnable = false;
	currconfigs.SupplyCurrentLimit = units::current::ampere_t(70);
	currconfigs.SupplyCurrentLimitEnable = true;
	currconfigs.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	currconfigs.SupplyCurrentLowerTime = units::time::second_t(0.5);
	m_ElevatorLeader->GetConfigurator().Apply(currconfigs);

	ClosedLoopRampsConfigs rampConfigs{};
	rampConfigs.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	m_ElevatorLeader->GetConfigurator().Apply(rampConfigs);
	HardwareLimitSwitchConfigs hwswitch{};
	hwswitch.ForwardLimitEnable = true;
	hwswitch.ForwardLimitRemoteSensorID = 0;
	hwswitch.ForwardLimitAutosetPositionEnable = true;
	hwswitch.ForwardLimitAutosetPositionValue = units::angle::turn_t(m_maxHeight.value());

	hwswitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	hwswitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	hwswitch.ReverseLimitEnable = true;
	hwswitch.ReverseLimitRemoteSensorID = 0;
	hwswitch.ReverseLimitAutosetPositionEnable = true;
	hwswitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	hwswitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	hwswitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;
	m_ElevatorLeader->GetConfigurator().Apply(hwswitch);

	MotorOutputConfigs motorconfig{};
	motorconfig.Inverted = InvertedValue::CounterClockwise_Positive;
	motorconfig.NeutralMode = NeutralModeValue::Brake;
	motorconfig.PeakForwardDutyCycle = 1;
	motorconfig.PeakReverseDutyCycle = -1;
	motorconfig.DutyCycleNeutralDeadband = 0;
	m_ElevatorLeader->GetConfigurator().Apply(motorconfig);
	TalonFXConfiguration fxConfig{};
	fxConfig.Feedback.FeedbackRemoteSensorID = 0;
	fxConfig.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::FusedCANcoder; // might need to switch to fully remote sensor, fused assumed perfect linerarity
	fxConfig.Feedback.SensorToMechanismRatio = 0.167531519;
	fxConfig.Feedback.RotorToSensorRatio = 7.6;
	m_ElevatorLeader->GetConfigurator().Apply(fxConfig);
}

void DragonTale::InitializeTalonSRXCoralPRACTICE_BOT9999()
{
	m_Coral->SetInverted(true);
	m_Coral->EnableVoltageCompensation(true);
	m_Coral->ConfigVoltageCompSaturation(10.0, 0);
	m_Coral->SetNeutralMode(ctre::phoenix::motorcontrol::NeutralMode::Brake);
	m_Coral->ConfigOpenloopRamp(0.25);

	ctre::phoenix::motorcontrol::SupplyCurrentLimitConfiguration climit;
	climit.enable = true;
	climit.currentLimit = 10;
	climit.triggerThresholdCurrent = 13;
	climit.triggerThresholdTime = 1;
	m_Coral->ConfigSupplyCurrentLimit(climit, 0);
}

void DragonTale::InitializeTalonSRXAlgaePRACTICE_BOT9999()
{
	m_Algae->SetInverted(true);
	m_Algae->EnableVoltageCompensation(true);
	m_Algae->ConfigVoltageCompSaturation(10.0, 0);
	m_Algae->SetNeutralMode(ctre::phoenix::motorcontrol::NeutralMode::Brake);
	m_Algae->ConfigOpenloopRamp(0.25);

	ctre::phoenix::motorcontrol::SupplyCurrentLimitConfiguration climit;
	climit.enable = true;
	climit.currentLimit = 10;
	climit.triggerThresholdCurrent = 13;
	climit.triggerThresholdTime = 1;
	m_Algae->ConfigSupplyCurrentLimit(climit, 0);
}

void DragonTale::InitializeTalonFXElevatorFollowerPRACTICE_BOT9999()
{
	CurrentLimitsConfigs currconfigs{};
	currconfigs.StatorCurrentLimit = units::current::ampere_t(0);
	currconfigs.StatorCurrentLimitEnable = false;
	currconfigs.SupplyCurrentLimit = units::current::ampere_t(70);
	currconfigs.SupplyCurrentLimitEnable = true;
	currconfigs.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	currconfigs.SupplyCurrentLowerTime = units::time::second_t(0.5);
	m_ElevatorFollower->GetConfigurator().Apply(currconfigs);

	ClosedLoopRampsConfigs rampConfigs{};
	rampConfigs.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	m_ElevatorFollower->GetConfigurator().Apply(rampConfigs);
	HardwareLimitSwitchConfigs hwswitch{};
	hwswitch.ForwardLimitEnable = true;
	hwswitch.ForwardLimitRemoteSensorID = 0;
	hwswitch.ForwardLimitAutosetPositionEnable = true;
	hwswitch.ForwardLimitAutosetPositionValue = units::angle::turn_t(m_maxHeight.value()); //(m_maxHeight / (units::length::inch_t(0.75))).value() * 3 / std::numbers::pi

	hwswitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	hwswitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	hwswitch.ReverseLimitEnable = true;
	hwswitch.ReverseLimitRemoteSensorID = 0;
	hwswitch.ReverseLimitAutosetPositionEnable = true;
	hwswitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	hwswitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	hwswitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;
	m_ElevatorFollower->GetConfigurator().Apply(hwswitch);

	MotorOutputConfigs motorconfig{};
	motorconfig.Inverted = InvertedValue::CounterClockwise_Positive;
	motorconfig.NeutralMode = NeutralModeValue::Brake;
	motorconfig.PeakForwardDutyCycle = 1;
	motorconfig.PeakReverseDutyCycle = -1;
	motorconfig.DutyCycleNeutralDeadband = 0;
	m_ElevatorFollower->GetConfigurator().Apply(motorconfig);
	m_ElevatorFollower->SetControl(ctre::phoenix6::controls::StrictFollower{8});
}

void DragonTale::SetPIDArmPositionDegree()
{
	Slot0Configs slot0Configs{};
	slot0Configs.kP = m_PositionDegree->GetP();
	slot0Configs.kI = m_PositionDegree->GetI();
	slot0Configs.kD = m_PositionDegree->GetD();
	m_Arm->GetConfigurator().Apply(slot0Configs);
}
void DragonTale::SetPIDElevatorLeaderPositionInch()
{
	Slot0Configs slot0Configs{};
	slot0Configs.kP = m_PositionInch->GetP();
	slot0Configs.kI = m_PositionInch->GetI();
	slot0Configs.kD = m_PositionInch->GetD();
	m_ElevatorLeader->GetConfigurator().Apply(slot0Configs);
}

void DragonTale::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
	PeriodicLooper::GetInstance()->RegisterAll(this);
}

void DragonTale::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();
	SetSensorFailSafe();
	ManualControl();
	UpdateTarget();
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void DragonTale::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void DragonTale::Update()
{
	m_Arm->SetControl(*m_ArmActiveTarget);
	m_ElevatorLeader->SetControl(*m_ElevatorLeaderActiveTarget);
	m_Coral->Set(ctre::phoenix::motorcontrol::TalonSRXControlMode::PercentOutput, m_CoralActiveTarget);
	m_Algae->Set(ctre::phoenix::motorcontrol::TalonSRXControlMode::PercentOutput, m_AlgaeActiveTarget);
}

bool DragonTale::IsAtMinPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMinTravel();
	// }
	return false;
}

bool DragonTale::IsAtMaxPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMaxTravel();
	// }
	return false;
}

void DragonTale::Cyclic()
{
	Update();

	CheckForTuningEnabled();
	if (m_tuning)
	{
		ReadTuningParamsFromNT();
	}
}

void DragonTale::CheckForTuningEnabled()
{
	bool pastTuning = m_tuning;
	m_tuning = m_table.get()->GetBoolean(m_tuningIsEnabledStr, false);
	if (pastTuning != m_tuning && m_tuning == true)
	{
		PushTuningParamsToNT();
	}
}

void DragonTale::ReadTuningParamsFromNT()
{
	m_PositionInch->SetIZone(m_table.get()->GetNumber("PositionInch_iZone", 0));
	m_PositionInch->SetF(m_table.get()->GetNumber("PositionInch_fGain", 0));
	m_PositionInch->SetP(m_table.get()->GetNumber("PositionInch_pGain", 0.2));
	m_PositionInch->SetI(m_table.get()->GetNumber("PositionInch_iGain", 0));
	m_PositionInch->SetD(m_table.get()->GetNumber("PositionInch_dGain", 0));
	m_PositionDegree->SetIZone(m_table.get()->GetNumber("PositionDegree_iZone", 0));
	m_PositionDegree->SetF(m_table.get()->GetNumber("PositionDegree_fGain", 0));
	m_PositionDegree->SetP(m_table.get()->GetNumber("PositionDegree_pGain", 0));
	m_PositionDegree->SetI(m_table.get()->GetNumber("PositionDegree_iGain", 0));
	m_PositionDegree->SetD(m_table.get()->GetNumber("PositionDegree_dGain", 0));
}

void DragonTale::PushTuningParamsToNT()
{
	m_table.get()->PutNumber("PositionInch_iZone", m_PositionInch->GetIZone());
	m_table.get()->PutNumber("PositionInch_fGain", m_PositionInch->GetF());
	m_table.get()->PutNumber("PositionInch_pGain", m_PositionInch->GetP());
	m_table.get()->PutNumber("PositionInch_iGain", m_PositionInch->GetI());
	m_table.get()->PutNumber("PositionInch_dGain", m_PositionInch->GetD());
	m_table.get()->PutNumber("PositionDegree_iZone", m_PositionDegree->GetIZone());
	m_table.get()->PutNumber("PositionDegree_fGain", m_PositionDegree->GetF());
	m_table.get()->PutNumber("PositionDegree_pGain", m_PositionDegree->GetP());
	m_table.get()->PutNumber("PositionDegree_iGain", m_PositionDegree->GetI());
	m_table.get()->PutNumber("PositionDegree_dGain", m_PositionDegree->GetD());
}

ControlData *DragonTale::GetControlData(string name)
{
	if (name.compare("PositionInch") == 0)
		return m_PositionInch;
	if (name.compare("PositionDegree") == 0)
		return m_PositionDegree;
	if (name.compare("PercentOutput") == 0)
		return m_PercentOutput;

	return nullptr;
}
/*==================================================================================================================

Hand-Coded Things are here :)

===================================================================================================================*/
void DragonTale::UpdateScoreMode(RobotStateChanges::StateChange change, int value)
{
	if (change == RobotStateChanges::StateChange::DesiredScoringMode_Int)
		m_scoringMode = static_cast<RobotStateChanges::ScoringMode>(value);
}

units::length::inch_t DragonTale::GetAlgaeHeight()
{
	frc::DriverStation::Alliance allianceColor = FMSData::GetInstance()->GetAllianceColor();
	frc::Pose2d chassisPose{};													  // TODO: get current chassis pose from visdrive later :)
	units::length::meter_t xDiff = units::length::meter_t(4.5) - chassisPose.X(); // TODO: get reef pose values from visdrive *thumbs up*
	units::length::meter_t yDiff = units::length::meter_t(4.0) - chassisPose.Y();
	units::angle::degree_t angleToReefCenter = units::math::atan2(yDiff, xDiff);

	// Adjust angleToReefCenter to be between -180 and 180 degrees
	angleToReefCenter = AngleUtils::GetEquivAngle(angleToReefCenter);

	// Calculate the angle relative to the closest 60-degree increment
	units::angle::degree_t angleRelativeToFace = units::angle::degree_t(units::math::fmod(angleToReefCenter + 30.0_deg, 60.0_deg) - 30.0_deg);

	// Adjust the angle to the nearest 60-degree increment
	units::angle::degree_t allianceAdjustment = allianceColor == frc::DriverStation::Alliance::kBlue ? units::angle::degree_t(180) : units::angle::degree_t(0);

	units::angle::degree_t closestMultiple = angleToReefCenter - angleRelativeToFace + allianceAdjustment;

	int multipleNumber = closestMultiple.value() / 60.0;

	if (multipleNumber % 2 == 0)
		return m_grabAlgaeHigh;
	else
		return m_grabAlgaeLow;
}

void DragonTale::UpdateTarget()
{
	units::angle::degree_t actualTargetAngle;
	units::length::inch_t actualTargetHeight = m_elevatorTarget;

	units::length::inch_t elevatorError = m_elevatorTarget - GetElevatorHeight();

	double circumference = 0.75 * std::numbers::pi;

	m_ElevatorLeader->SetPosition(units::angle::turn_t(GetElevatorHeight().value() / circumference * 3));

	if (elevatorError > m_elevatorErrorThreshold)
	{
		actualTargetAngle = units::angle::degree_t(90);
	}
	else
	{
		actualTargetAngle = m_armTarget;
	}

	// TODO: Add logic to determine to not raise the elevator until we are close to scoring using chassis pose (Potentially)
	UpdateTargetArmPositionDegree(actualTargetAngle);
	UpdateTargetElevatorLeaderPositionInch(actualTargetHeight);
}

void DragonTale::ManualControl()
{
	units::inch_t ElevatorChange = units::inch_t(TeleopControl::GetInstance()->GetAxisValue(TeleopControlFunctions::ELAVATOR) * m_elevatorChangeRate);
	units::angle::degree_t ArmChange = units::angle::degree_t(TeleopControl::GetInstance()->GetAxisValue(TeleopControlFunctions::ARM) * m_armChangeRate);

	m_elevatorTarget += ElevatorChange;
	m_armTarget += ArmChange;
}

void DragonTale::SetSensorFailSafe()
{
	if (TeleopControl::GetInstance()->IsButtonPressed(TeleopControlFunctions::MANUAL_ON))
	{
		m_manualMode = true;
	}
	else if (TeleopControl::GetInstance()->IsButtonPressed(TeleopControlFunctions::MANUAL_OFF))
	{
		m_manualMode = false;
	}
}

bool DragonTale::AtTarget()
{
	return ((units::math::abs(m_elevatorTarget - GetElevatorHeight()) < m_elevatorAtTargetThreshold) && (units::math::abs(m_armTarget - GetArmAngle()) < m_ArmAtTargetThreshold));
}