//====================================================================================================================================================
// Copyright 2025 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.25.00.05
// Generated on Sunday, February 16, 2025 9:43:58 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>

#include "DragonTale.h"
#include "utils/logging/Logger.h"
#include "utils/PeriodicLooper.h"
#include "state/RobotState.h"

#include "ctre/phoenix6/TalonFX.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configs.hpp"
#include <ctre/phoenix/motorcontrol/can/TalonSRX.h>
#include <ctre/phoenix/motorcontrol/SupplyCurrentLimitConfiguration.h>
#include "ctre/phoenix6/TalonFXS.hpp"
#include <frc/DigitalInput.h>
#include <frc/filter/Debouncer.h>
#include <ctre/phoenix6/CANcoder.hpp>
#include <ctre/phoenix6/configs/Configurator.hpp>
#include <ctre/phoenix6/signals/SpnEnums.hpp>
#include "mechanisms/DragonTale/InitializeState.h"
#include "mechanisms/DragonTale/ReadyState.h"
#include "mechanisms/DragonTale/HumanPlayerLoadState.h"
#include "mechanisms/DragonTale/GrabAlgaeReefState.h"
#include "mechanisms/DragonTale/HoldState.h"
#include "mechanisms/DragonTale/GrabAlgaeFloorState.h"
#include "mechanisms/DragonTale/ProcessState.h"
#include "mechanisms/DragonTale/NetState.h"
#include "mechanisms/DragonTale/ScoreAlgaeState.h"
#include "mechanisms/DragonTale/L1ScoringPositionState.h"
#include "mechanisms/DragonTale/L2ScoringPositionState.h"
#include "mechanisms/DragonTale/L3ScoringPositionState.h"
#include "mechanisms/DragonTale/L4ScoringPositionState.h"
#include "mechanisms/DragonTale/ScoreCoralState.h"
#include "mechanisms/DragonTale/ManualCoralLoadState.h"
#include "mechanisms/DragonTale/ManualGrabAlgaeReefState.h"
#include "mechanisms/DragonTale/ManualGrabAlgaeFloorState.h"
#include "fielddata/DragonTargetFinder.h"

#include "teleopcontrol/TeleopControl.h"
#include "teleopcontrol/TeleopControlFunctions.h"

#include "utils/AngleUtils.h"
#include "utils/FMSData.h"
#include "tuple"

using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::Slot1Configs;
using ctre::phoenix6::configs::TalonFXConfiguration;
using ctre::phoenix6::configs::TalonFXSConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;
using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::MotorArrangementValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;

using std::string;
using std::tuple;
using namespace DragonTaleStates;

void DragonTale::CreateAndRegisterStates()
{
	InitializeState *InitializeStateInst = new InitializeState(string("Initialize"), 0, this, m_activeRobotId);
	AddToStateVector(InitializeStateInst);

	ReadyState *ReadyStateInst = new ReadyState(string("Ready"), 1, this, m_activeRobotId);
	AddToStateVector(ReadyStateInst);

	HumanPlayerLoadState *HumanPlayerLoadStateInst = new HumanPlayerLoadState(string("HumanPlayerLoad"), 2, this, m_activeRobotId);
	AddToStateVector(HumanPlayerLoadStateInst);

	GrabAlgaeReefState *GrabAlgaeReefStateInst = new GrabAlgaeReefState(string("GrabAlgaeReef"), 3, this, m_activeRobotId);
	AddToStateVector(GrabAlgaeReefStateInst);

	HoldState *HoldStateInst = new HoldState(string("Hold"), 4, this, m_activeRobotId);
	AddToStateVector(HoldStateInst);

	GrabAlgaeFloorState *GrabAlgaeFloorStateInst = new GrabAlgaeFloorState(string("GrabAlgaeFloor"), 5, this, m_activeRobotId);
	AddToStateVector(GrabAlgaeFloorStateInst);

	ProcessState *ProcessStateInst = new ProcessState(string("Process"), 6, this, m_activeRobotId);
	AddToStateVector(ProcessStateInst);

	NetState *NetStateInst = new NetState(string("Net"), 7, this, m_activeRobotId);
	AddToStateVector(NetStateInst);

	ScoreAlgaeState *ScoreAlgaeStateInst = new ScoreAlgaeState(string("ScoreAlgae"), 8, this, m_activeRobotId);
	AddToStateVector(ScoreAlgaeStateInst);

	L1ScoringPositionState *L1ScoringPositionStateInst = new L1ScoringPositionState(string("L1ScoringPosition"), 9, this, m_activeRobotId);
	AddToStateVector(L1ScoringPositionStateInst);

	L2ScoringPositionState *L2ScoringPositionStateInst = new L2ScoringPositionState(string("L2ScoringPosition"), 10, this, m_activeRobotId);
	AddToStateVector(L2ScoringPositionStateInst);

	L3ScoringPositionState *L3ScoringPositionStateInst = new L3ScoringPositionState(string("L3ScoringPosition"), 11, this, m_activeRobotId);
	AddToStateVector(L3ScoringPositionStateInst);

	L4ScoringPositionState *L4ScoringPositionStateInst = new L4ScoringPositionState(string("L4ScoringPosition"), 12, this, m_activeRobotId);
	AddToStateVector(L4ScoringPositionStateInst);

	ScoreCoralState *ScoreCoralStateInst = new ScoreCoralState(string("ScoreCoral"), 13, this, m_activeRobotId);
	AddToStateVector(ScoreCoralStateInst);

	ManualCoralLoadState *ManualCoralLoadStateInst = new ManualCoralLoadState(string("ManualCoralLoad"), 14, this, m_activeRobotId);
	AddToStateVector(ManualCoralLoadStateInst);

	ManualGrabAlgaeReefState *ManualGrabAlgaeReefStateInst = new ManualGrabAlgaeReefState(string("ManualGrabAlgaeReef"), 15, this, m_activeRobotId);
	AddToStateVector(ManualGrabAlgaeReefStateInst);

	ManualGrabAlgaeFloorState *ManualGrabAlgaeFloorStateInst = new ManualGrabAlgaeFloorState(string("ManualGrabAlgaeFloor"), 16, this, m_activeRobotId);
	AddToStateVector(ManualGrabAlgaeFloorStateInst);

	InitializeStateInst->RegisterTransitionState(ReadyStateInst);
	ReadyStateInst->RegisterTransitionState(HumanPlayerLoadStateInst);
	ReadyStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	ReadyStateInst->RegisterTransitionState(GrabAlgaeFloorStateInst);
	HumanPlayerLoadStateInst->RegisterTransitionState(ReadyStateInst);
	HumanPlayerLoadStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	HumanPlayerLoadStateInst->RegisterTransitionState(HoldStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(ReadyStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(HumanPlayerLoadStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(HoldStateInst);
	GrabAlgaeReefStateInst->RegisterTransitionState(GrabAlgaeFloorStateInst);
	HoldStateInst->RegisterTransitionState(ReadyStateInst);
	HoldStateInst->RegisterTransitionState(HumanPlayerLoadStateInst);
	HoldStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	HoldStateInst->RegisterTransitionState(GrabAlgaeFloorStateInst);
	HoldStateInst->RegisterTransitionState(ProcessStateInst);
	HoldStateInst->RegisterTransitionState(NetStateInst);
	HoldStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	HoldStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	HoldStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	HoldStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	GrabAlgaeFloorStateInst->RegisterTransitionState(ReadyStateInst);
	GrabAlgaeFloorStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	GrabAlgaeFloorStateInst->RegisterTransitionState(HoldStateInst);
	ProcessStateInst->RegisterTransitionState(ReadyStateInst);
	ProcessStateInst->RegisterTransitionState(HoldStateInst);
	ProcessStateInst->RegisterTransitionState(NetStateInst);
	ProcessStateInst->RegisterTransitionState(ScoreAlgaeStateInst);
	NetStateInst->RegisterTransitionState(ReadyStateInst);
	NetStateInst->RegisterTransitionState(HoldStateInst);
	NetStateInst->RegisterTransitionState(ProcessStateInst);
	NetStateInst->RegisterTransitionState(ScoreAlgaeStateInst);
	ScoreAlgaeStateInst->RegisterTransitionState(ReadyStateInst);
	ScoreAlgaeStateInst->RegisterTransitionState(HoldStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	L1ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	L2ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	L3ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(ReadyStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(HoldStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	L4ScoringPositionStateInst->RegisterTransitionState(ScoreCoralStateInst);
	ScoreCoralStateInst->RegisterTransitionState(ReadyStateInst);
	ScoreCoralStateInst->RegisterTransitionState(GrabAlgaeReefStateInst);
	ScoreCoralStateInst->RegisterTransitionState(HoldStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(ReadyStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L1ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L2ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L3ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(L4ScoringPositionStateInst);
	ManualCoralLoadStateInst->RegisterTransitionState(ManualGrabAlgaeReefStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ReadyStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ProcessStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(NetStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ManualCoralLoadStateInst);
	ManualGrabAlgaeReefStateInst->RegisterTransitionState(ManualGrabAlgaeFloorStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ReadyStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ProcessStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(NetStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ManualCoralLoadStateInst);
	ManualGrabAlgaeFloorStateInst->RegisterTransitionState(ManualGrabAlgaeReefStateInst);
}

DragonTale::DragonTale(RobotIdentifier activeRobotId) : BaseMech(MechanismTypes::MECHANISM_TYPE::DRAGON_TALE, std::string("DragonTale")),
														m_activeRobotId(activeRobotId),
														m_stateMap()
{
	m_scoringMode = RobotStateChanges::ScoringMode::Coral;
	RobotState *m_robotState = RobotState::GetInstance();

	m_robotState->RegisterForStateChanges(this, RobotStateChanges::StateChange::DesiredScoringMode_Int);
	m_robotState->RegisterForStateChanges(this, RobotStateChanges::StateChange::ChassisPose_Pose2D);
	PeriodicLooper::GetInstance()->RegisterAll(this);
}

std::map<std::string, DragonTale::STATE_NAMES> DragonTale::stringToSTATE_NAMESEnumMap{
	{"STATE_INITIALIZE", DragonTale::STATE_NAMES::STATE_INITIALIZE},
	{"STATE_READY", DragonTale::STATE_NAMES::STATE_READY},
	{"STATE_HUMAN_PLAYER_LOAD", DragonTale::STATE_NAMES::STATE_HUMAN_PLAYER_LOAD},
	{"STATE_GRAB_ALGAE_REEF", DragonTale::STATE_NAMES::STATE_GRAB_ALGAE_REEF},
	{"STATE_HOLD", DragonTale::STATE_NAMES::STATE_HOLD},
	{"STATE_GRAB_ALGAE_FLOOR", DragonTale::STATE_NAMES::STATE_GRAB_ALGAE_FLOOR},
	{"STATE_PROCESS", DragonTale::STATE_NAMES::STATE_PROCESS},
	{"STATE_NET", DragonTale::STATE_NAMES::STATE_NET},
	{"STATE_SCORE_ALGAE", DragonTale::STATE_NAMES::STATE_SCORE_ALGAE},
	{"STATE_L1SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L1SCORING_POSITION},
	{"STATE_L2SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L2SCORING_POSITION},
	{"STATE_L3SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L3SCORING_POSITION},
	{"STATE_L4SCORING_POSITION", DragonTale::STATE_NAMES::STATE_L4SCORING_POSITION},
	{"STATE_SCORE_CORAL", DragonTale::STATE_NAMES::STATE_SCORE_CORAL},
	{"STATE_MANUAL_CORAL_LOAD", DragonTale::STATE_NAMES::STATE_MANUAL_CORAL_LOAD},
	{"STATE_MANUAL_GRAB_ALGAE_REEF", DragonTale::STATE_NAMES::STATE_MANUAL_GRAB_ALGAE_REEF},
	{"STATE_MANUAL_GRAB_ALGAE_FLOOR", DragonTale::STATE_NAMES::STATE_MANUAL_GRAB_ALGAE_FLOOR},
};

void DragonTale::CreatePRACTICE_BOT9999()
{
	m_ntName = "DragonTale";
	m_Arm = new ctre::phoenix6::hardware::TalonFX(17, "rio");
	m_ElevatorLeader = new ctre::phoenix6::hardware::TalonFX(4, "canivore");
	m_CoralTalonSRX = new ctre::phoenix::motorcontrol::can::TalonSRX(18);
	m_AlgaeTalonFX = new ctre::phoenix6::hardware::TalonFX(19, "rio");
	m_ElevatorFollower = new ctre::phoenix6::hardware::TalonFX(16, "canivore");

	m_CoralInSensor = new frc::DigitalInput(0);	 // yellow wire reverse
	m_CoralOutSensor = new frc::DigitalInput(1); // black
	m_AlgaeSensor = new frc::DigitalInput(2);	 // red reverse this one

	ctre::phoenix6::configs::CANcoderConfiguration ArmAngleSensorConfigs{};
	ArmAngleSensorConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(0.421387);
	ArmAngleSensorConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::Clockwise_Positive;
	m_ArmAngleSensor = new ctre::phoenix6::hardware::CANcoder(17, "rio");
	m_ArmAngleSensor->GetConfigurator().Apply(ArmAngleSensorConfigs);
	ctre::phoenix6::configs::CANcoderConfiguration ElevatorHeightSensorConfigs{};
	ElevatorHeightSensorConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(-0.15673828125);
	ElevatorHeightSensorConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_ElevatorHeightSensor = new ctre::phoenix6::hardware::CANcoder(4, "canivore");
	m_ElevatorHeightSensor->GetConfigurator().Apply(ElevatorHeightSensorConfigs);

	m_PositionInch = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_INCH,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionInch",								  // std::string indentifier
		2.5,											  // double proportional
		0.35,											  // double integral
		0,												  // double derivative
		0.3,											  // double feedforward
		0.3,											  // double velocityGain
		0.05,											  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
		0,										// double integralZone
		0,										// double maxAcceleration
		0,										// double cruiseVelocity
		0,										// double peakValue
		0,										// double nominalValue
		true									// bool enableFOC
	);
	m_PositionDegree = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegree",								  // std::string indentifier
		57,												  // double proportional
		25,												  // double integral
		5,												  // double derivative
		1.8,											  // double feedforward
		0.75,											  // double velocityGain
		0.25,											  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
		0,										// double integralZone
		0,										// double maxAcceleration
		0,										// double cruiseVelocity
		0,										// double peakValue
		0,										// double nominalValue
		true									// bool enableFOC
	);
	m_PercentOutput = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOutput",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
		0,										// double integralZone
		0,										// double maxAcceleration
		0,										// double cruiseVelocity
		0,										// double peakValue
		0,										// double nominalValue
		false									// bool enableFOC
	);

	ReadConstants("DragonTale.xml", 9999);

	m_table = nt::NetworkTableInstance::GetDefault().GetTable(m_ntName);
	m_tuningIsEnabledStr = "Enable Tuning for " + m_ntName; // since this string is used every loop, we do not want to create the string every time
	m_table.get()->PutBoolean(m_tuningIsEnabledStr, m_tuning);
}

void DragonTale::CreateCOMP_BOT302()
{
	m_ntName = "DragonTale";
	m_Arm = new ctre::phoenix6::hardware::TalonFX(17, "canivore");
	m_ElevatorLeader = new ctre::phoenix6::hardware::TalonFX(4, "canivore");
	m_ElevatorFollower = new ctre::phoenix6::hardware::TalonFX(16, "canivore");
	m_CoralTalonFXS = new ctre::phoenix6::hardware::TalonFXS(18, "canivore");
	m_AlgaeTalonFXS = new ctre::phoenix6::hardware::TalonFXS(19, "canivore");

	m_CoralInSensor = new frc::DigitalInput(2);
	m_CoralOutSensor = new frc::DigitalInput(1);
	m_AlgaeSensor = new frc::DigitalInput(0);

	ctre::phoenix6::configs::CANcoderConfiguration ArmAngleSensorConfigs{};
	ArmAngleSensorConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(0.248779);
	ArmAngleSensorConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_ArmAngleSensor = new ctre::phoenix6::hardware::CANcoder(17, "canivore");
	m_ArmAngleSensor->GetConfigurator().Apply(ArmAngleSensorConfigs);
	ctre::phoenix6::configs::CANcoderConfiguration ElevatorHeightSensorConfigs{};
	ElevatorHeightSensorConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t(0.116699);
	ElevatorHeightSensorConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_ElevatorHeightSensor = new ctre::phoenix6::hardware::CANcoder(4, "canivore");
	m_ElevatorHeightSensor->GetConfigurator().Apply(ElevatorHeightSensorConfigs);

	m_PositionInch = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_INCH,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionInch",								  // std::string indentifier
		2.5,											  // double proportional
		0.35,											  // double integral
		0,												  // double derivative
		0.3,											  // double feedforward
		0.3,											  // double velocityGain
		0.05,											  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
		0,										// double integralZone
		0,										// double maxAcceleration
		0,										// double cruiseVelocity
		0,										// double peakValue
		0,										// double nominalValue
		true									// bool enableFOC
	);
	m_PositionDegree = new ControlData(
		ControlModes::CONTROL_TYPE::POSITION_DEGREES,	  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PositionDegree",								  // std::string indentifier
		57,												  // double proportional
		25,												  // double integral
		5,												  // double derivative
		1.8,											  // double feedforward
		0.75,											  // double velocityGain
		0.25,											  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
		0,										// double integralZone
		0,										// double maxAcceleration
		0,										// double cruiseVelocity
		0,										// double peakValue
		0,										// double nominalValue
		true									// bool enableFOC
	);
	m_PercentOutput = new ControlData(
		ControlModes::CONTROL_TYPE::PERCENT_OUTPUT,		  // ControlModes::CONTROL_TYPE mode
		ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
		"m_PercentOutput",								  // std::string indentifier
		0,												  // double proportional
		0,												  // double integral
		0,												  // double derivative
		0,												  // double feedforward
		0,												  // double velocityGain
		0,												  // double accelartionGain
		0,												  // double staticFrictionGain,

		ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
		0,										// double integralZone
		0,										// double maxAcceleration
		0,										// double cruiseVelocity
		0,										// double peakValue
		0,										// double nominalValue
		false									// bool enableFOC
	);

	ReadConstants("DragonTale.xml", 302);

	m_table = nt::NetworkTableInstance::GetDefault().GetTable(m_ntName);
	m_tuningIsEnabledStr = "Enable Tuning for " + m_ntName; // since this string is used every loop, we do not want to create the string every time
	m_table.get()->PutBoolean(m_tuningIsEnabledStr, m_tuning);
}

void DragonTale::InitializePRACTICE_BOT9999()
{
	InitializeTalonFXArmPRACTICE_BOT9999();
	InitializeTalonFXElevatorLeaderPRACTICE_BOT9999();
	InitializeTalonSRXCoralPRACTICE_BOT9999();
	InitializeTalonFXAlgaePRACTICE_BOT9999();
	InitializeTalonFXElevatorFollowerPRACTICE_BOT9999();
}

void DragonTale::InitializeCOMP_BOT302()
{
	InitializeTalonFXArmCOMP_BOT302();
	InitializeTalonFXElevatorLeaderCOMP_BOT302();
	InitializeTalonFXElevatorFollowerCOMP_BOT302();
	InitializeTalonFXSCoralCOMP_BOT302();
	InitializeTalonFXSAlgaeCOMP_BOT302();
}
void DragonTale::InitializeTalonFXArmPRACTICE_BOT9999()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(120);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.25);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackRemoteSensorID = 17;
	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::FusedCANcoder;
	configs.Feedback.SensorToMechanismRatio = 1;
	configs.Feedback.RotorToSensorRatio = 240;

	configs.MotionMagic.MotionMagicCruiseVelocity = 75_tps;
	configs.MotionMagic.MotionMagicAcceleration = 100_tr_per_s_sq;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Arm->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Arm", "m_Arm Status", status.GetName());

	SetPIDArmPositionDegree();
}

void DragonTale::InitializeTalonFXElevatorLeaderPRACTICE_BOT9999()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(0);
	configs.CurrentLimits.StatorCurrentLimitEnable = false;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.5);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::turn_t(m_maxHeight.value());

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackRemoteSensorID = 4;
	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RemoteCANcoder;
	configs.Feedback.SensorToMechanismRatio = 0.108878152421;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_ElevatorLeader->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_ElevatorLeader", "m_ElevatorLeader Status", status.GetName());
}

void DragonTale::InitializeTalonSRXCoralPRACTICE_BOT9999()
{
	m_CoralTalonSRX->SetInverted(true);
	m_CoralTalonSRX->EnableVoltageCompensation(true);
	m_CoralTalonSRX->ConfigVoltageCompSaturation(10.0, 0);
	m_CoralTalonSRX->SetNeutralMode(ctre::phoenix::motorcontrol::NeutralMode::Brake);
	m_CoralTalonSRX->ConfigOpenloopRamp(0.25);

	ctre::phoenix::motorcontrol::SupplyCurrentLimitConfiguration climit;
	climit.enable = true;
	climit.currentLimit = 10;
	climit.triggerThresholdCurrent = 13;
	climit.triggerThresholdTime = 1;
	m_CoralTalonSRX->ConfigSupplyCurrentLimit(climit, 0);
}

void DragonTale::InitializeTalonFXAlgaePRACTICE_BOT9999()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(0);
	configs.CurrentLimits.StatorCurrentLimitEnable = false;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.5);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.OpenLoopRamps.VoltageOpenLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RotorSensor;
	configs.Feedback.SensorToMechanismRatio = 1;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_AlgaeTalonFX->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_AlgaeTalonFX", "m_AlgaeTalonFX Status", status.GetName());
}

void DragonTale::InitializeTalonFXElevatorFollowerPRACTICE_BOT9999()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(0);
	configs.CurrentLimits.StatorCurrentLimitEnable = false;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.5);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(m_maxHeight.value());

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_ElevatorFollower->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_ElevatorFollower", "m_ElevatorFollower Status", status.GetName());

	m_ElevatorFollower->SetControl(ctre::phoenix6::controls::StrictFollower{4});
}

void DragonTale::InitializeTalonFXArmCOMP_BOT302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(120);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.25);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 2;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = m_maxAngle;
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::RemoteCANdiS1; // Verify S1/S2
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 2;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = m_minAngle;
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::RemoteCANdiS2; // Verify S1/S2
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackRemoteSensorID = 17;
	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::FusedCANcoder;
	configs.Feedback.SensorToMechanismRatio = 1;
	configs.Feedback.RotorToSensorRatio = 180;

	configs.MotionMagic.MotionMagicCruiseVelocity = 75_tps;
	configs.MotionMagic.MotionMagicAcceleration = 100_tr_per_s_sq;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_Arm->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_Arm", "m_Arm Status", status.GetName());

	SetPIDArmPositionDegree();
}

void DragonTale::InitializeTalonFXElevatorLeaderCOMP_BOT302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(0);
	configs.CurrentLimits.StatorCurrentLimitEnable = false;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(35);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.5);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::turn_t(m_maxHeight.value()); //(m_maxHeight / (units::length::inch_t(0.75))).value() * 3 / std::numbers::pi
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::RemoteCANdiS1;				  // Verify S1/S2
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::RemoteCANdiS2; // Verify S1/S2
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::CounterClockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Feedback.FeedbackRemoteSensorID = 4;
	configs.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::RemoteCANcoder;
	configs.Feedback.SensorToMechanismRatio = 0.108878152421;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_ElevatorLeader->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_ElevatorLeader", "m_ElevatorLeader Status", status.GetName());
}

void DragonTale::InitializeTalonFXElevatorFollowerCOMP_BOT302()
{
	TalonFXConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(0);
	configs.CurrentLimits.StatorCurrentLimitEnable = false;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(70);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.5);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.ClosedLoopRamps.TorqueClosedLoopRampPeriod = units::time::second_t(0.25);

	configs.HardwareLimitSwitch.ForwardLimitEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::turn_t(m_maxHeight.value()); //(m_maxHeight / (units::length::inch_t(0.75))).value() * 3 / std::numbers::pi
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::RemoteCANdiS1;				  // Verify S1/S2
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 1;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = true;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::RemoteCANdiS2; // Verify S1/S2
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_ElevatorFollower->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_ElevatorFollower", "m_ElevatorFollower Status", status.GetName());

	m_ElevatorFollower->SetControl(ctre::phoenix6::controls::StrictFollower{4});
}

void DragonTale::InitializeTalonFXSCoralCOMP_BOT302()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.2);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.OpenLoopRamps.VoltageOpenLoopRampPeriod = units::time::second_t(0.2);

	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_CoralTalonFXS->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_CoralTalonFXS", "m_CoralTalonFXS Status", status.GetName());
}

void DragonTale::InitializeTalonFXSAlgaeCOMP_BOT302()
{
	TalonFXSConfiguration configs{};
	configs.CurrentLimits.StatorCurrentLimit = units::current::ampere_t(60);
	configs.CurrentLimits.StatorCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLimitEnable = true;
	configs.CurrentLimits.SupplyCurrentLowerLimit = units::current::ampere_t(40);
	configs.CurrentLimits.SupplyCurrentLowerTime = units::time::second_t(0.2);

	configs.Voltage.PeakForwardVoltage = units::voltage::volt_t(11.0);
	configs.Voltage.PeakReverseVoltage = units::voltage::volt_t(-11.0);
	configs.OpenLoopRamps.VoltageOpenLoopRampPeriod = units::time::second_t(0.25);
	configs.HardwareLimitSwitch.ForwardLimitEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ForwardLimitAutosetPositionValue = units::angle::degree_t(0);

	configs.HardwareLimitSwitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	configs.HardwareLimitSwitch.ReverseLimitEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitRemoteSensorID = 0;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionEnable = false;
	configs.HardwareLimitSwitch.ReverseLimitAutosetPositionValue = units::angle::degree_t(0);
	configs.HardwareLimitSwitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	configs.HardwareLimitSwitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;

	configs.MotorOutput.Inverted = InvertedValue::Clockwise_Positive;
	configs.MotorOutput.NeutralMode = NeutralModeValue::Brake;
	configs.MotorOutput.PeakForwardDutyCycle = 1;
	configs.MotorOutput.PeakReverseDutyCycle = -1;
	configs.MotorOutput.DutyCycleNeutralDeadband = 0;

	configs.Commutation.MotorArrangement = MotorArrangementValue::Minion_JST;

	ctre::phoenix::StatusCode status = ctre::phoenix::StatusCode::StatusCodeNotInitialized;
	for (int i = 0; i < 5; ++i)
	{
		status = m_AlgaeTalonFXS->GetConfigurator().Apply(configs, units::time::second_t(0.25));
		if (status.IsOK())
			break;
	}
	if (!status.IsOK())
		Logger::GetLogger()->LogData(LOGGER_LEVEL::ERROR, "m_AlgaeTalonFXS", "m_AlgaeTalonFXS Status", status.GetName());
}

void DragonTale::SetPIDArmPositionDegree()
{
	Slot0Configs slot0Configs{};
	slot0Configs.kP = m_PositionDegree->GetP();
	slot0Configs.kI = m_PositionDegree->GetI();
	slot0Configs.kD = m_PositionDegree->GetD();
	slot0Configs.kG = m_PositionDegree->GetF();
	slot0Configs.kS = m_PositionDegree->GetS();
	slot0Configs.kV = m_PositionDegree->GetV();
	slot0Configs.kA = m_PositionDegree->GetA();
	slot0Configs.GravityType = ctre::phoenix6::signals::GravityTypeValue::Arm_Cosine;
	slot0Configs.StaticFeedforwardSign = ctre::phoenix6::signals::StaticFeedforwardSignValue(0); // uses Velcoity Sign
	m_Arm->GetConfigurator().Apply(slot0Configs, units::time::second_t(0.25));
	m_ArmPositionDegree.EnableFOC = m_PositionDegree->IsFOCEnabled();
}
void DragonTale::SetPIDElevatorLeaderPositionInch()
{
	Slot0Configs slot0Configs{};
	slot0Configs.kP = m_PositionInch->GetP();
	slot0Configs.kI = m_PositionInch->GetI();
	slot0Configs.kD = m_PositionInch->GetD();
	slot0Configs.kG = m_PositionInch->GetF();
	slot0Configs.kS = m_PositionInch->GetS();
	slot0Configs.kV = m_PositionInch->GetV();
	slot0Configs.kA = m_PositionInch->GetA();
	slot0Configs.GravityType = ctre::phoenix6::signals::GravityTypeValue::Elevator_Static;
	slot0Configs.StaticFeedforwardSign = ctre::phoenix6::signals::StaticFeedforwardSignValue(0); // uses Velcoity Sign
	m_ElevatorLeader->GetConfigurator().Apply(slot0Configs);
	m_ElevatorLeaderPositionInch.EnableFOC = m_PositionInch->IsFOCEnabled();
}

void DragonTale::SetCurrentState(int state, bool run)
{
	StateMgr::SetCurrentState(state, run);
	PeriodicLooper::GetInstance()->RegisterAll(this);
}

void DragonTale::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	SetSensorFailSafe();
	ManualControl();
	UpdateTarget();
	Cyclic();

	// TODO: Remove this logging once we have datalogging and have both robots in a swell condition :)
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Coral In Sensor", GetCoralInSensorState());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Coral Out Sensor", GetCoralOutSensorState());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Algae Sensor", GetAlgaeSensorState());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Arm Angle Method (Abs)", GetArmAngle().value());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Elevator Target", m_elevatorTarget.value());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Elevator Height Method", GetElevatorHeight().value());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Elevator Height CANCoder", m_ElevatorHeightSensor->GetPosition().GetValueAsDouble());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Dragon Tale Scoring Mode", m_scoringMode);
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "State", GetCurrentState());
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Limit Switch Reverse", m_ElevatorLeader->GetReverseLimit().GetValue().value);
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Limit Switch Forward", m_ElevatorLeader->GetForwardLimit().GetValue().value);
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void DragonTale::SetControlConstants(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid)
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void DragonTale::Update()
{
	m_Arm->SetControl(*m_ArmActiveTarget);
	m_ElevatorLeader->SetControl(*m_ElevatorLeaderActiveTarget);

	if (m_activeRobotId == RobotIdentifier::PRACTICE_BOT_9999)
	{
		m_CoralTalonSRX->Set(ctre::phoenix::motorcontrol::TalonSRXControlMode::PercentOutput, m_CoralTalonSRXActiveTarget);
		m_AlgaeTalonFX->SetControl(*m_AlgaeTalonFXActiveTarget);
	}
	else
	{
		m_CoralTalonFXS->SetControl(*m_CoralTalonFXSActiveTarget);
		m_AlgaeTalonFXS->SetControl(*m_AlgaeTalonFXSActiveTarget);
	}
}

bool DragonTale::IsAtMinPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMinTravel();
	// }
	return false;
}

bool DragonTale::IsAtMaxPosition(RobotElementNames::MOTOR_CONTROLLER_USAGE identifier) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMaxTravel();
	// }
	return false;
}

void DragonTale::Cyclic()
{
	Update();

	CheckForTuningEnabled();
	if (m_tuning)
	{
		ReadTuningParamsFromNT();
	}
}

void DragonTale::CheckForTuningEnabled()
{
	bool pastTuning = m_tuning;
	m_tuning = m_table.get()->GetBoolean(m_tuningIsEnabledStr, false);
	if (pastTuning != m_tuning && m_tuning == true)
	{
		PushTuningParamsToNT();
	}
}

void DragonTale::ReadTuningParamsFromNT()
{
	m_PositionInch->SetIZone(m_table.get()->GetNumber("PositionInch_iZone", 0));
	m_PositionInch->SetS(m_table.get()->GetNumber("PositionInch_sGain", 0));
	m_PositionInch->SetV(m_table.get()->GetNumber("PositionInch_vGain", 0.3));
	m_PositionInch->SetA(m_table.get()->GetNumber("PositionInch_aGain", 0.05));
	m_PositionInch->SetF(m_table.get()->GetNumber("PositionInch_fGain", 0.3));
	m_PositionInch->SetP(m_table.get()->GetNumber("PositionInch_pGain", 2.5));
	m_PositionInch->SetI(m_table.get()->GetNumber("PositionInch_iGain", 0.35));
	m_PositionInch->SetD(m_table.get()->GetNumber("PositionInch_dGain", 0));
	m_PositionDegree->SetIZone(m_table.get()->GetNumber("PositionDegree_iZone", 0));
	m_PositionDegree->SetS(m_table.get()->GetNumber("PositionDegree_sGain", 0));
	m_PositionDegree->SetV(m_table.get()->GetNumber("PositionDegree_vGain", 0.75));
	m_PositionDegree->SetA(m_table.get()->GetNumber("PositionDegree_aGain", 0.25));
	m_PositionDegree->SetF(m_table.get()->GetNumber("PositionDegree_fGain", 1.8));
	m_PositionDegree->SetP(m_table.get()->GetNumber("PositionDegree_pGain", 57));
	m_PositionDegree->SetI(m_table.get()->GetNumber("PositionDegree_iGain", 25));
	m_PositionDegree->SetD(m_table.get()->GetNumber("PositionDegree_dGain", 5));
}

void DragonTale::PushTuningParamsToNT()
{
	m_table.get()->PutNumber("PositionInch_iZone", m_PositionInch->GetIZone());
	m_table.get()->PutNumber("PositionInch_sGain", m_PositionInch->GetS());
	m_table.get()->PutNumber("PositionInch_vGain", m_PositionInch->GetV());
	m_table.get()->PutNumber("PositionInch_aGain", m_PositionInch->GetA());
	m_table.get()->PutNumber("PositionInch_fGain", m_PositionInch->GetF());
	m_table.get()->PutNumber("PositionInch_pGain", m_PositionInch->GetP());
	m_table.get()->PutNumber("PositionInch_iGain", m_PositionInch->GetI());
	m_table.get()->PutNumber("PositionInch_dGain", m_PositionInch->GetD());
	m_table.get()->PutNumber("PositionDegree_iZone", m_PositionDegree->GetIZone());
	m_table.get()->PutNumber("PositionDegree_sGain", m_PositionDegree->GetS());
	m_table.get()->PutNumber("PositionDegree_vGain", m_PositionDegree->GetV());
	m_table.get()->PutNumber("PositionDegree_aGain", m_PositionDegree->GetA());
	m_table.get()->PutNumber("PositionDegree_fGain", m_PositionDegree->GetF());
	m_table.get()->PutNumber("PositionDegree_pGain", m_PositionDegree->GetP());
	m_table.get()->PutNumber("PositionDegree_iGain", m_PositionDegree->GetI());
	m_table.get()->PutNumber("PositionDegree_dGain", m_PositionDegree->GetD());
}

ControlData *DragonTale::GetControlData(string name)
{
	if (name.compare("PositionInch") == 0)
		return m_PositionInch;
	if (name.compare("PositionDegree") == 0)
		return m_PositionDegree;
	if (name.compare("PercentOutput") == 0)
		return m_PercentOutput;

	return nullptr;
}
/*==================================================================================================================

Hand-Coded Things are here :)

===================================================================================================================*/
void DragonTale::NotifyStateUpdate(RobotStateChanges::StateChange change, int value)
{
	if (RobotStateChanges::StateChange::DesiredScoringMode_Int == change)
		m_scoringMode = static_cast<RobotStateChanges::ScoringMode>(value);
}

void DragonTale::SetSensorFailSafe()
{
	if (TeleopControl::GetInstance()->IsButtonPressed(TeleopControlFunctions::MANUAL_ON))
	{
		m_manualMode = true;
	}
	else if (TeleopControl::GetInstance()->IsButtonPressed(TeleopControlFunctions::MANUAL_OFF))
	{
		m_manualMode = false;
	}
}

units::length::inch_t DragonTale::GetAlgaeHeight()
{
	units::length::inch_t algeHeight = m_grabAlgaeLow;
	// Adjust the angle to the nearest 60-degree increment
	auto info = (DragonTargetFinder::GetInstance()->GetPose(DragonTargetFinderTarget::CLOSEST_REEF_ALGAE));
	if (info)
	{
		frc::Pose2d algaePose = std::get<frc::Pose2d>(info.value());

		units::angle::degree_t closestMultiple = algaePose.Rotation().Degrees() - 180_deg;

		int multipleNumber = closestMultiple.value() / 60.0;

		if (multipleNumber % 2 == 0)
			algeHeight = m_grabAlgaeHigh;
	}
	return algeHeight;
}

void DragonTale::ManualControl()
{
	double elevatorInput = TeleopControl::GetInstance()->GetAxisValue(TeleopControlFunctions::ELAVATOR);
	double armInput = TeleopControl::GetInstance()->GetAxisValue(TeleopControlFunctions::ARM);

	units::inch_t ElevatorChange = (abs(elevatorInput) > 0.05) ? units::length::inch_t(elevatorInput * m_elevatorChangeRate) : units::length::inch_t(0);
	units::angle::degree_t ArmChange = (abs(armInput) > 0.05) ? units::angle::degree_t(armInput * m_armChangeRate) : units::angle::degree_t(0);

	SetElevatorTarget(m_elevatorTarget + ElevatorChange);
	SetArmTarget(m_armTarget + ArmChange);
}

void DragonTale::UpdateTarget()
{
	units::angle::degree_t actualTargetAngle = m_armTarget;
	units::length::inch_t actualTargetHeight = m_elevatorTarget;

	units::length::inch_t elevatorError = units::math::abs(m_elevatorTarget - GetElevatorHeight());

	if (elevatorError > m_elevatorErrorThreshold)
	{
		actualTargetAngle = units::angle::degree_t(70);
	}
	else if (GetElevatorHeight() < m_elevatorProtectionHeight && m_armTarget < m_armProtectionAngle)
	{
		actualTargetAngle = m_armProtectionAngle;
	}
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, "DragonTale", "Arm Angle Target", actualTargetAngle.value());

	// TODO: Add logic to determine to not raise the elevator until we are close to scoring using chassis pose (Potentially)
	UpdateTargetArmPositionDegree(actualTargetAngle);
	UpdateTargetElevatorLeaderPositionInch(actualTargetHeight);
}

void DragonTale::NotifyStateUpdate(RobotStateChanges::StateChange change, frc::Pose2d value)
{
	if (RobotStateChanges::StateChange::ChassisPose_Pose2D == change)
		m_robotPose = value;
}

bool DragonTale::AtTarget()
{
	return ((units::math::abs(m_elevatorTarget - GetElevatorHeight()) < m_elevatorAtTargetThreshold) && (units::math::abs(m_armTarget - GetArmAngle()) < m_ArmAtTargetThreshold));
}