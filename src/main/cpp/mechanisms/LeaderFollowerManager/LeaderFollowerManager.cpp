// clang-format off
//====================================================================================================================================================
// Copyright 2025 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 20.25.00.02
// Generated on Sunday, January 26, 2025 9:07:35 AM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>

#include "LeaderFollowerManager.h"
#include "utils/logging/Logger.h"
#include "utils/PeriodicLooper.h"

#include "ctre/phoenix6/TalonFX.hpp"
#include "ctre/phoenix6/controls/Follower.hpp"
#include "ctre/phoenix6/configs/Configs.hpp"
#include <ctre/phoenix6/CANcoder.hpp>
#include <ctre/phoenix6/configs/Configurator.hpp>
#include <ctre/phoenix6/signals/SpnEnums.hpp>
#include "mechanisms/LeaderFollowerManager/OffState.h"
#include "mechanisms/LeaderFollowerManager/MidState.h"
#include "mechanisms/LeaderFollowerManager/HighState.h"

using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix6::configs::HardwareLimitSwitchConfigs;
using ctre::phoenix6::configs::CurrentLimitsConfigs;
using ctre::phoenix6::configs::MotorOutputConfigs;
using ctre::phoenix6::configs::Slot0Configs;
using ctre::phoenix6::configs::ClosedLoopRampsConfigs;
using ctre::phoenix6::configs::OpenLoopRampsConfigs;
using ctre::phoenix6::configs::TalonFXConfiguration;
using ctre::phoenix6::signals::FeedbackSensorSourceValue;

using std::string;
using namespace LeaderFollowerManagerStates;

void LeaderFollowerManager::CreateAndRegisterStates()
{
	OffState* OffStateInst = new OffState ( string ( "Off" ), 0, this, m_activeRobotId );
	AddToStateVector ( OffStateInst );

	MidState* MidStateInst = new MidState ( string ( "Mid" ), 1, this, m_activeRobotId );
	AddToStateVector ( MidStateInst );

	HighState* HighStateInst = new HighState ( string ( "High" ), 2, this, m_activeRobotId );
	AddToStateVector ( HighStateInst );

	OffStateInst->RegisterTransitionState ( MidStateInst );
	OffStateInst->RegisterTransitionState ( HighStateInst );
	MidStateInst->RegisterTransitionState ( OffStateInst );
	MidStateInst->RegisterTransitionState ( HighStateInst );
	HighStateInst->RegisterTransitionState ( OffStateInst );
	HighStateInst->RegisterTransitionState ( MidStateInst );
}

LeaderFollowerManager::LeaderFollowerManager ( MechanismConfigMgr::RobotIdentifier activeRobotId ) : BaseMech ( MechanismTypes::MECHANISM_TYPE::LEADER_FOLLOWER_MANAGER, std::string ( "LeaderFollowerManager" ) ),
	m_activeRobotId ( activeRobotId ),
	m_stateMap()
{
	PeriodicLooper::GetInstance()->RegisterAll ( this );
}

std::map<std::string, LeaderFollowerManager::STATE_NAMES> LeaderFollowerManager::stringToSTATE_NAMESEnumMap
{
	{"STATE_OFF", LeaderFollowerManager::STATE_NAMES::STATE_OFF},
	{"STATE_MID", LeaderFollowerManager::STATE_NAMES::STATE_MID},
	{"STATE_HIGH", LeaderFollowerManager::STATE_NAMES::STATE_HIGH},};

void LeaderFollowerManager::CreateThingThree3()
{
	m_ntName = "LeaderFollowerManager";
	m_Leader = new ctre::phoenix6::hardware::TalonFX ( 2, "canivore" );
	m_Follower = new ctre::phoenix6::hardware::TalonFX ( 11, "canivore" );






	ctre::phoenix6::configs::CANcoderConfiguration LeaderCANcoderConfigs{};
	LeaderCANcoderConfigs.MagnetSensor.MagnetOffset = units::angle::turn_t ( 0 );
	LeaderCANcoderConfigs.MagnetSensor.SensorDirection = ctre::phoenix6::signals::SensorDirectionValue::CounterClockwise_Positive;
	m_LeaderCANcoder = new ctre::phoenix6::hardware::CANcoder ( 12,"canivore" );
	m_LeaderCANcoder->GetConfigurator().Apply ( LeaderCANcoderConfigs );

	m_PosInch = new ControlData (
	    ControlModes::CONTROL_TYPE::POSITION_INCH, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "m_PosInch", // std::string indentifier
	    0, // double proportional
	    0, // double integral
	    0, // double derivative
	    0, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    0, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    0, // double peakValue
	    0, // double nominalValue
	    true  // bool enableFOC
	);

	ReadConstants ( "LeaderFollowerManager.xml", 3 );

	m_table = nt::NetworkTableInstance::GetDefault().GetTable ( m_ntName );
	m_tuningIsEnabledStr = "Enable Tuning for " + m_ntName; // since this string is used every loop, we do not want to create the string every time
	m_table.get()->PutBoolean ( m_tuningIsEnabledStr, m_tuning );
}

void LeaderFollowerManager::InitializeThingThree3()
{
	InitializeTalonFXLeaderThingThree3();
	InitializeTalonFXFollowerThingThree3();
}
void LeaderFollowerManager::InitializeTalonFXLeaderThingThree3()
{
	CurrentLimitsConfigs currconfigs{};
	currconfigs.StatorCurrentLimit = units::current::ampere_t ( 0 );
	currconfigs.StatorCurrentLimitEnable = false;
	currconfigs.SupplyCurrentLimit = units::current::ampere_t ( 70 );
	currconfigs.SupplyCurrentLimitEnable = true;
	currconfigs.SupplyCurrentLowerLimit = units::current::ampere_t ( 35 );
	currconfigs.SupplyCurrentLowerTime = units::time::second_t ( 0.25 );
	m_Leader->GetConfigurator().Apply ( currconfigs );

	ClosedLoopRampsConfigs rampConfigs{};
	rampConfigs.TorqueClosedLoopRampPeriod = units::time::second_t ( 0.5 );
	m_Leader->GetConfigurator().Apply ( rampConfigs );
	HardwareLimitSwitchConfigs hwswitch{};
	hwswitch.ForwardLimitEnable = false;
	hwswitch.ForwardLimitRemoteSensorID = 0;
	hwswitch.ForwardLimitAutosetPositionEnable = false;
	hwswitch.ForwardLimitAutosetPositionValue = units::angle::degree_t ( 0 );

	hwswitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	hwswitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	hwswitch.ReverseLimitEnable = false;
	hwswitch.ReverseLimitRemoteSensorID = 0;
	hwswitch.ReverseLimitAutosetPositionEnable = false;
	hwswitch.ReverseLimitAutosetPositionValue = units::angle::degree_t ( 0 );
	hwswitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	hwswitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;
	m_Leader->GetConfigurator().Apply ( hwswitch );

	MotorOutputConfigs motorconfig{};
	motorconfig.Inverted = InvertedValue::CounterClockwise_Positive;
	motorconfig.NeutralMode = NeutralModeValue::Brake;
	motorconfig.PeakForwardDutyCycle = 1;
	motorconfig.PeakReverseDutyCycle = -1;
	motorconfig.DutyCycleNeutralDeadband = 0;
	m_Leader->GetConfigurator().Apply ( motorconfig );
	TalonFXConfiguration fxConfig{};
	fxConfig.Feedback.FeedbackRemoteSensorID = 12;
	fxConfig.Feedback.FeedbackSensorSource = FeedbackSensorSourceValue::SyncCANcoder;
	fxConfig.Feedback.SensorToMechanismRatio = 1;
	fxConfig.Feedback.RotorToSensorRatio = 1;
	m_Leader->GetConfigurator().Apply ( fxConfig );
}

void LeaderFollowerManager::InitializeTalonFXFollowerThingThree3()
{
	CurrentLimitsConfigs currconfigs{};
	currconfigs.StatorCurrentLimit = units::current::ampere_t ( 0 );
	currconfigs.StatorCurrentLimitEnable = false;
	currconfigs.SupplyCurrentLimit = units::current::ampere_t ( 70 );
	currconfigs.SupplyCurrentLimitEnable = true;
	currconfigs.SupplyCurrentLowerLimit = units::current::ampere_t ( 35 );
	currconfigs.SupplyCurrentLowerTime = units::time::second_t ( 0.25 );
	m_Follower->GetConfigurator().Apply ( currconfigs );

	ClosedLoopRampsConfigs rampConfigs{};
	rampConfigs.TorqueClosedLoopRampPeriod = units::time::second_t ( 0.5 );
	m_Follower->GetConfigurator().Apply ( rampConfigs );
	HardwareLimitSwitchConfigs hwswitch{};
	hwswitch.ForwardLimitEnable = false;
	hwswitch.ForwardLimitRemoteSensorID = 0;
	hwswitch.ForwardLimitAutosetPositionEnable = false;
	hwswitch.ForwardLimitAutosetPositionValue = units::angle::degree_t ( 0 );

	hwswitch.ForwardLimitSource = ForwardLimitSourceValue::LimitSwitchPin;
	hwswitch.ForwardLimitType = ForwardLimitTypeValue::NormallyOpen;

	hwswitch.ReverseLimitEnable = false;
	hwswitch.ReverseLimitRemoteSensorID = 0;
	hwswitch.ReverseLimitAutosetPositionEnable = false;
	hwswitch.ReverseLimitAutosetPositionValue = units::angle::degree_t ( 0 );
	hwswitch.ReverseLimitSource = ReverseLimitSourceValue::LimitSwitchPin;
	hwswitch.ReverseLimitType = ReverseLimitTypeValue::NormallyOpen;
	m_Follower->GetConfigurator().Apply ( hwswitch );

	MotorOutputConfigs motorconfig{};
	motorconfig.Inverted = InvertedValue::Clockwise_Positive;
	motorconfig.NeutralMode = NeutralModeValue::Brake;
	motorconfig.PeakForwardDutyCycle = 1;
	motorconfig.PeakReverseDutyCycle = -1;
	motorconfig.DutyCycleNeutralDeadband = 0;
	m_Follower->GetConfigurator().Apply ( motorconfig );
}






// LeaderCANcoder : CANcoder inputs do not have initialization needs

void LeaderFollowerManager::SetPIDLeaderPosInch()
{
	Slot0Configs slot0Configs{};
	slot0Configs.kP = m_PosInch->GetP();
	slot0Configs.kI = m_PosInch->GetI();
	slot0Configs.kD = m_PosInch->GetD();
	m_Leader->GetConfigurator().Apply ( slot0Configs );
}
void LeaderFollowerManager::SetPIDFollowerPosInch()
{
	Slot0Configs slot0Configs{};
	slot0Configs.kP = m_PosInch->GetP();
	slot0Configs.kI = m_PosInch->GetI();
	slot0Configs.kD = m_PosInch->GetD();
	m_Follower->GetConfigurator().Apply ( slot0Configs );
}

void LeaderFollowerManager::SetCurrentState ( int state, bool run )
{
	StateMgr::SetCurrentState ( state, run );
	PeriodicLooper::GetInstance()->RegisterAll ( this );
}

void LeaderFollowerManager::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();
}


/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void LeaderFollowerManager::SetControlConstants ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid )
{
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void LeaderFollowerManager::Update()
{
	m_Leader->SetControl ( *m_LeaderActiveTarget );
	m_Follower->SetControl ( *m_FollowerActiveTarget );
}




bool LeaderFollowerManager::IsAtMinPosition ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier ) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMinTravel();
	// }
	return false;
}

bool LeaderFollowerManager::IsAtMaxPosition ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier ) const
{
	// auto motor = GetMotorMech(identifier);
	// if (motor != nullptr)
	// {
	//     return motor->IsAtMaxTravel();
	// }
	return false;
}






void LeaderFollowerManager::Cyclic()
{
	Update();

	CheckForTuningEnabled();
	if ( m_tuning )
	{
		ReadTuningParamsFromNT();
	}
}

void LeaderFollowerManager::CheckForTuningEnabled()
{
	bool pastTuning = m_tuning;
	m_tuning = m_table.get()->GetBoolean ( m_tuningIsEnabledStr, false );
	if ( pastTuning != m_tuning && m_tuning == true )
	{
		PushTuningParamsToNT();
	}
}

void LeaderFollowerManager::ReadTuningParamsFromNT()
{
	m_PosInch->SetIZone ( m_table.get()->GetNumber ( "PosInch_iZone", 0 ) );
	m_PosInch->SetF ( m_table.get()->GetNumber ( "PosInch_fGain", 0 ) );
	m_PosInch->SetP ( m_table.get()->GetNumber ( "PosInch_pGain", 0 ) );
	m_PosInch->SetI ( m_table.get()->GetNumber ( "PosInch_iGain", 0 ) );
	m_PosInch->SetD ( m_table.get()->GetNumber ( "PosInch_dGain", 0 ) );

}

void LeaderFollowerManager::PushTuningParamsToNT()
{
	m_table.get()->PutNumber ( "PosInch_iZone", m_PosInch->GetIZone() );
	m_table.get()->PutNumber ( "PosInch_fGain", m_PosInch->GetF() );
	m_table.get()->PutNumber ( "PosInch_pGain", m_PosInch->GetP() );
	m_table.get()->PutNumber ( "PosInch_iGain", m_PosInch->GetI() );
	m_table.get()->PutNumber ( "PosInch_dGain", m_PosInch->GetD() );
}

ControlData *LeaderFollowerManager::GetControlData ( string name )
{
	if ( name.compare ( "PosInch" ) == 0 )
		return m_PosInch;


	return nullptr;
}